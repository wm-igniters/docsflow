import { PublishAdapter, PublishUser } from "@/lib/services/PublishService";
import { DocSchema, IDoc } from "@/models/Doc";
import { DB_CONFIG } from "@/lib/config.mjs";
import { Model } from "mongoose";

function displayUser(user: PublishUser) {
  return user.name || user.email || "docsflow";
}

function formatEditor(name?: string | null, email?: string | null) {
  if (name && email && name !== email) return `${name} (${email})`;
  if (email) return email;
  if (name) return name;
  return "Unknown";
}

function collectEditors(doc: IDoc) {
  const editors: { name?: string | null; email?: string | null }[] = [];
  const seen = new Set<string>();
  const history = Array.isArray(doc.history) ? doc.history : [];
  for (const entry of history) {
    const name = entry?.user?.name || entry?.user?.id || entry?.updated_by || null;
    const email = entry?.user?.id || entry?.user?.email || null;
    const key = `${name || ""}|${email || ""}`.toLowerCase();
    if (!seen.has(key) && (name || email)) {
      seen.add(key);
      editors.push({ name, email });
    }
  }
  if (editors.length === 0) {
    const fallbackName = doc.last_updated_by || "Unknown";
    return [formatEditor(fallbackName, null)];
  }
  return editors.map((e) => formatEditor(e.name, e.email));
}

export const releaseNotesPublishAdapter: PublishAdapter<IDoc> = {
  entity: "release-notes",
  modelName: "Doc",
  collectionName: DB_CONFIG.COLLECTIONS.RELEASE_NOTES,
  schema: DocSchema,
  buildQuery: (docId?: string | null) => {
    const query: Record<string, any> = { status: { $ne: "published" } };
    if (docId) {
      query.path = docId;
    }
    return query;
  },
  getDocPath: (doc) => doc.path,
  getDocContent: (doc) => doc.docsflow_data ?? doc.github_data ?? "",
  buildCommitMessage: (docs, user) => {
    const editorLines = docs
      .map((doc) => {
        const editors = collectEditors(doc);
        return `- ${doc.path}: ${editors.join(", ")}`;
      })
      .join("\n");
    return `docs(release-notes): update ${docs.length} file(s)\n\nPublished via DocsFlow by ${displayUser(user)}\n\nEditors:\n${editorLines}`;
  },
  buildPrTitle: (docs) => {
    if (docs.length === 1) {
      const name = docs[0].path.split("/").pop() || docs[0].path;
      return `docs(release-notes): update ${name}`;
    }
    return `docs(release-notes): update ${docs.length} files`;
  },
  buildPrBody: (docs) =>
    `This Pull Request was automatically generated by DocsFlow.\n\n### Updated Files:\n${docs
      .map((d) => `- ${d.path}`)
      .join("\n")}`,
  updateAfterPublish: async (
    model: Model<IDoc>,
    docs: IDoc[],
    info
  ) => {
    const userLabel = displayUser(info.user);
    const updates = docs.map((doc) => {
      const content = doc.docsflow_data ?? doc.github_data ?? "";
      return model.updateOne(
        { _id: doc._id },
        {
          $set: {
            github_data: content,
            docsflow_data: content,
            status: "published",
            last_updated_source: "docsflow",
            last_updated_by: userLabel,
            last_update_timestamp: info.publishedAt,
            commit_details: {
              last_commit_id: info.commitSha,
              timestamp: info.publishedAt,
              username: userLabel,
            },
          },
        }
      );
    });
    await Promise.all(updates);
  },
};
